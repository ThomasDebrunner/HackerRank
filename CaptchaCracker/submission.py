import numpy as np
from sklearn.svm import SVC
from sklearn.externals import joblib
import sys


def read_training_data():
    n_training_samples = 25
    training_samples = []
    for i in range(n_training_samples):
        with open('sampleCaptchas/input/input%02d.txt' % i, 'r') as f:
            image = read_data(f)
        with open('sampleCaptchas/output/output%02d.txt' % i) as f:
            solution = next(f)
        training_samples.append((image, solution))
    return training_samples


def read_data(file):
    # read width and height
    height, width = [int(x) for x in next(file).split()]

    # prepare image buffer
    image_buffer = []

    # read the pixels line by line
    for line in file:
        pixel_strs = [x for x in line.split()]

        if len(pixel_strs) != width:
            raise ValueError("Incorrect length")

        line_buffer = []

        for pixel_str in pixel_strs:
            pvalues = ([int(x) for x in pixel_str.split(',')])
            gray_value = int(round(0.1140 * pvalues[0] + 0.5870 * pvalues[1] + 0.2989 * pvalues[2]))

            line_buffer.append(gray_value)

        image_buffer.append(line_buffer)

    return image_buffer


def threshold_filter(image):
    """ Sets all pixel with a value above threshold to 255 """
    threshold = 100

    for y in range(len(image)):
        for x in range(len(image[y])):
            if image[y][x] > threshold:
                image[y][x] = 255


def is_column_empty(image, column):
    """Returns true, if the column is empty"""
    for y in range(len(image)):
        if image[y][column] < 255:
            return False
    return True


def find_y_bounds(image):
    """Returns the y bounds of the image"""
    lower_bound = -1
    upper_bound = -1
    for y in range(len(image)):
        row_empty = True
        for pixel in image[y]:
            if pixel < 255:
                row_empty = False
                break
        if not row_empty and lower_bound == -1:
            lower_bound = y
        if row_empty and lower_bound != -1 and upper_bound == -1:
            upper_bound = y

    return lower_bound, upper_bound


def extract_characters(image):
    """ Extracts the characters from the image using the functions defined above """
    # filter image
    threshold_filter(image)

    # find the y bounds
    lower_y, upper_y = find_y_bounds(image)

    character_starts = []
    in_character = False
    for x in range(len(image[0])):
        if is_column_empty(image, x):
            if in_character:
                in_character = False

        else:
            if not in_character:
                in_character = True
                character_starts.append(x)

    np_image = np.array(image)
    characters = []
    for character_start in character_starts:
        characters.append(np_image[lower_y:upper_y, character_start:character_start+8])

    return characters


def prepare_training_set():
    """ Loads the training set and prepares the data """
    raw_training_data = read_training_data()
    training_set = []
    training_solution_set = []

    # iterate through all training example
    for example in raw_training_data:
        image = example[0]
        solution = example[1]
        characters = extract_characters(image)

        for i in range(len(characters)):
            # only add classes we have not yet had an example before. A little hacky, but minimizes model size
            if not solution[i] in training_solution_set:
                training_set.append(characters[i].ravel())
                training_solution_set.append(solution[i])

    clf = SVC(C=100, gamma=0.0001)
    clf.fit(training_set, training_solution_set)
    joblib.dump(clf, 'model.pkl', compress=9)


def main():
    # uncomment this to create new model
    # prepare_training_set()

    # UGLY HACK TO HAVE MODEL IN SOURCECODE. HACKERRANK SPECIFIC!
    model = bytes.fromhex('5A463078623035332020202020202020202020202078DAED5DDB771BC5195FC7018481204080300284A20AA11AD5F72405BA1B1B3044C40405C2422F8B24AF2D35BA7DD2CA6D7A4ECF691F02F55BFF8DBEF53FE86B9FFB17F4F4B52FED7BCFA13392768D67359ADBCA76C27C9C2FB22E73F97E33F3DD6676F8C37CAD7FB7E9567AED62FFB055AC352BFDBEDB5FB87D677B018C37FF0873BF870B797BC1308CB6D31F74BB9D9EE7C07CAD3D6875EF156B9D9E5B6C0D9A5EA3D2EB55EE2D383DB7D669F7BDDEA0E62DC0C5D1AF16DA7BA36FE19192711F1EDD9EABC263DF42AC0C8FE74B73A5EC7D5818FF70CFBBD77517E009FB026AAEB10E4F968CD2DCB7F054192EE54BF3F61CFAF41D787A7777F7C6778886FF940C0FE2D5A3ED3FE32FCF13C3331E3C5BB59F427F0E31757EE3360EEA08BBE7EA17EB4320127584C2F36578618CC28BF591E0FB57213912FCA5322C22C1EB61915FAE1E6DA5713343FA8FA95F27BF42CA8357AAF663E88DD3EF567A7D175E3DB29FC06FF70695A653EBB8FB0EBCE60F491A0FC9EB65C8E021B95CCA7E0397EB8B475B5FBF1142FA6FFA75E2ABA97112C247E3C4878FC6494CF3697C344E51E0636A7C344E11E2636A7C7ED038991AA733C1C7D4F8FC207032354EE70A1F53E3F350E1646A9C1E087C4C8DCF038993A9717AA0F131353EE71A2753E3F450E2636A7CC4706A687C4EBC364E673E3DAC3BCD1A9FD3C1C9D438697C147032354E1A1F059CF4C92A8D8F0A4E1A170A4E90F5E047557B1EBDF13A4DC8ED98B7AA37FFF1DFBFFC6F78F6B4D1F6DC5ECDED7A0EBCE11FD6CBE3C37A6F96A1902FCDDD3CBC701F7E8CCFEAFDF5394393264D9A3469D2A44993264D9A3469D2A44993264DE78860C983B7AAA3C772BF97E92BFA99BE9FE04CDF721956FC4CDFAACEF469D2A44993264D9A3469D2A44993264D9A3469D274FE08D63C58AFDA8FA03F0F2AAD56053676CCC5CD7FFD3BB5FD961D33C65725BA7D0736FDDCDF159CFBBB5A866BE35B127F3ABE25F1F315787B744BE23B6578D7BF25B17411FD17F3E067F84AC865F4B315C4AB88D710AF23DE40BC89F80AE2AB88AF21BE8E780BF136E2F710BF8FF803C43B883F44FC11E21B884B883F467C13F12EE24F10DF42FC29E232E2DB883FC35D437C07F117886DC45F22FE0A0B6F7A6055ED278D935742C2F5DDA1ECC1ED9A5BBEECDB58F6F7CAF0FE58F60FEA97905869F45B5CC725C4F862C38B8871F9C7113F8D3883F865C4CF237E05F1A3885F18E37FD918DD4EF93AE26711E3EB29F191CB671027112F22C6E72D5F458CD3AB78A0528813885F421C478CD3B4AF21C6A3F022166BC7830FAB36FE73CFAD35FA8D4EDBD91FB46B1EFEA35FAF745DF868D78E7F4FC243B7E6757A68946FF89296B0A41F97E1E650D2D2AD6F6017A77887B061FA67C79AF86A2C5927E617ED77A1720C62968BF1D51BFA3C27D8BFCCF87D4A4CCE10F9076D79CBA729F56C08F63F3B5DAE50B9229F9C3EFE8661098D1FEF7831CB1524E7DD925CBB611A7F1EB784DA0FD5B722593E2E27BF2AEEACF9C55D3E1751FF639CBF4F10E5C8F786E0FABE32BD3ED9794BD6273B5ECAE3BB74520FCD7C3D6F5A27F4E4ACE791E8782BCB4792BF7E93C4F7EBD6547B11509E522F653D1A6F73CE4FCAFC3B2DFD12ACA3A2683B27EDF469F73BF2F5E7DBD7BC98BE25E7136BBD047E4DD23A53B98FE53CA92767E64766ADE9FE5156125F96FFC9EAD7EAE4FA8375417C4FDA13D24FF4F1E41E87B4A25D16F47343E533D674FB97E51BF7107E6BE7D35F0A5186CFDF61CEBFB4A21E8CCABF2C10F627A9360F59E3C01B17D0E20061FF2A29E6CF33FBCFD21F9CFE36A93F23F30769FD4A5B53FD8640AF07FAC19A89FE0CF99394B84D36BE60E947E13C06E90FA638E7DB06A59E1861DF0C4B6DFD0AFAE3B4786BE671BDA4DD518E039282B8BC2BD99EAA3E2EA89567DAA34DDEF882739E27D4E6236D5CC9F84916672A31FAC7D4FF947836D03B69C1F14911EB8333AE0BF44B92826B42CE3F0ED54FD183CCFEAD53CA17D4FC5BA6FDE1C52F6551F2BF82EB3D2B98FF8ECBF919547965F57F7EFAFAE39EBFCBD1C45FD4F86F454DDEC8F2410941BD23B8FE84F71F12D3FD5C517B2C6ABF58FA959EC73526AE7361FF314DCBB709FA3F71B979129293B4B71922AE65CC1F61BB56A0E8FD4DC57CA7A05DA5E9035ADC4C5BBFBCF625A09C9C5DA3D523BCBF409BBFBCFE4591A2EF68EB48787D52FC0C469C15B423E82719D7A2C9D74BFBCFAB11C553B2FB6592F114CD1F142D27BAEF16AC971CA79F9220CA11F3839CD7A43F15E805D6FA4F73E214578B9F827C09917714DEBFF7694D517FA42DA1F197CDAB53F37F8CFC26D37F16D57F29CAFA4930FAC779AE2494878F31F2F7CAF9636BA25E3FF5FC35A1DF697979FA7A97EC7F9ACF6ECC4C7E7FDE9896DAF871FAA7A49E0ACAA727E79B43FB848CF7A78E9FAFAF25F767A9F6C2A725CEB83019CDF80997CF9E31FE71B1FC91B03E58E58CCF397108F4722122F9AF4584BFECFCE13D57C78A6B79ED6F8CC8270A9ED364C66149B57C334BEF85DA15F47F43FA4256FE8C98DF4BD5F7A2F9BFF4647F989A17C831EC8B6CFC6A48FA6F2BD3E34D7EFC48BD22172F09CF1F5A7E814682E7D0027D1993D427294B285F3E6B7F50BA7CE68CFA1F3B5D7F32349F697A7E55313E4B2BE2A98A47EE8CC633AAFC487236FD67DAFDD874FF2CF09B0A8A7909C1783A94CF8829CE4F5EFF674B0E5FE6BE32195771EAED1009FAF3C1F8C664F507C51FE38CEBD8F19135353F253C7E643F65FD8F44C4EB5BB57C42513F1424CBAF2BCABF74C6F82D5BD1E0978E463F87F2C9F1E97E8968FB815E8E89C501C13C27CBD1CEB3A5ACE9F9A4FC74FB463D6F92A3E43739E3C110B1CE0F1A33CA3F93FDCF088E5F280E3AE5FC39657C55DB679E938953E44F4ECEFB52DBA7EC4F73DB7386BF427B2E93DA5ECAE22B5F10EC2F19A793C4A9BF43F17A56D0FE32FACDBDFF73D5E2F3A77C52DCDF573DF74D6D87788E8DFBB9A2BC62FE2DAEE86F47A53FE2D3F52CAFBFCA9DD7E3DCA7A4DA395E7DB0CAC853A9CE9F754AFDBCF387386FA96CBF42C4B0FB34F965F75F54FD3F55FF352AFF5DF1F940AA7FC4AB9F59E7B4F2D644BBCAB2B7547BB43639EF34EBFC1275FF5EB67D9A9F9AE5F32B59F99DA09E24438FB0C68F786E933BBE2D32E4A0F915718ABF43FA4919B1F82BA8372FA9BF52965ABE6483310F639476921697FE135EB7AC7DCDD4F4F840397FE28F3F6FFE2D3B3D6F259B0F0DF9F5E4795496FD593E9DF86966CF752778EDB3623BAAF98EA215115E72F5B1FD309A9FCAB07F343D5894D357CA38F9FD59921CA75844E3A49A57536D5F761F52F57971D575C2FBBC926CFC9621FC45DEE79BE2D3FDFB99C78F29226F9CB3C4EC0F8DE292E5D382FE4B8C88579382FDCF31FC88B45A9E9DAABF58F16F5E12BF8CA0FE8E29FAEFB993715F287F403BA7CD8B83E4731EB4BC86F07332BEDE8A13E32E9BDF917D7E397E12EF59E97F61FF3D439947BCF7EF65CE387F46DE6F9714D307A1714D88E535A9FE0E19D7A527C71DD4BC10F1FC4DD89F9ABC0E79CF61862821977F09E5577292FACB974FFAFC1B392ED1E8E9603D91F8AC48AEDF8CE2FA177D2E88E6872BFA51CC7DC66541FD41E9A7F4FE21AFFD5D8D36FF458BBFA9E352E0AC7F4D6E7F6056FBF23AFEE08C2762727E24B73C1B92F264E4DA97BEF74572FC65E79D681E2D94D7CF9FD13A5921FCC538C34F3AD6CFF08907B746B766F72AEDBD4ECBE97B15CF854F776D7CE375BFDE6BB4EF36DA0750FE93BD30FCA0D2759DFD86E7C0EDD155D29FD9F80AEC3DF7A0E7BAF079697E78FD78ADE3EE2FC39D1DBF411B5FA5ED76FB8D66A70D5F1C7F8C8B767B9DEA75076CFFB6EA2FF16DD55F95E1E7F8B66AF4FE17F5C5A36D037EE9C1AFAAC30277DD5EDB6D8263E3BBB57BD57DF87AD8A6D368759B5019B5EFF40F6B30FA9F1EE2CE62A1067D076A2563781B78ABF25BA7E1B93DD8BBF11DA2A01F5B0EB87E3FF6713F0ECA501FF7A381FA5147BDF8F5A817CEE88AF5BBC757ACE32BBBDB03681E8B8711AB556A75D7E9377EE742ABF4771BDF0FBE0DEDD2DEF0CBBD41A5E960B01CE8D433C3EEE26E54AA8D66C3BB07DDA32170876EAFDAE9BB0047836AF1FF475C3E5F')
    with open('model.pkl', 'wb') as f:
        f.write(model)

    # END UGLY HACK TO HAVE MODEL IN SOURCECODE. HACKERRANK SPECIFIC!

    # load model back
    clf = joblib.load('model.pkl')

    # read sample
    image = read_data(sys.stdin)

    # extract the characters
    characters = extract_characters(image)

    for character in characters:
        prediction = clf.predict(character.ravel().reshape(1, -1))
        sys.stdout.write(prediction[0])

    sys.stdout.write('\n')

if __name__ == '__main__':
    main()
